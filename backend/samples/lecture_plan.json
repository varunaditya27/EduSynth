{
  "topic": "Binary Trees : From Zero to Interview",
  "language": "en",
  "theme": "chalkboard",
  "duration_minutes": 25,
  "slides": [
    {
      "index": 1,
      "title": "What Is a Binary Tree?",
      "points": [
        "A binary tree is a hierarchical data structure where each node can have at most two children, commonly referred to as the left child and the right child.",
        "It is composed of nodes connected by edges, with a single distinguished node called the root and zero or more recursively defined subtrees.",
        "Binary trees are not inherently ordered; ordering rules (like BST invariants or heap properties) are layered on top of the basic binary-tree shape."
      ],
      "diagram": "compare"
    },
    {
      "index": 2,
      "title": "Key Vocabulary You’ll See Everywhere",
      "points": [
        "Depth/Level: the number of edges from the root to a node; Height: the number of edges on the longest path from a node to a leaf.",
        "Leaf: a node with no children; Internal node: a node with at least one child; Sibling: nodes that share the same parent.",
        "Balanced vs. Skewed: a tree is ‘balanced’ if subtrees are roughly equal in height; skew occurs when most nodes lean to one side, degrading performance."
      ],
      "diagram": "process"
    },
    {
      "index": 3,
      "title": "Tree Shape & Performance Trade-offs",
      "points": [
        "Balanced trees keep operations near O(log n) by ensuring height stays small, which minimizes the path length between the root and leaves.",
        "Skewed trees (e.g., every node only has a right child) can degrade lookups and inserts toward O(n) because the structure behaves like a linked list.",
        "Practical implementations often enforce balance (AVL, Red-Black) or use heaps/tries depending on the access pattern and required invariants."
      ],
      "diagram": "compare"
    },
    {
      "index": 4,
      "title": "Traversal Patterns (The Big Three)",
      "points": [
        "Preorder (Root → Left → Right): great for copying a tree or serializing structure because you visit parents before their children.",
        "Inorder (Left → Root → Right): on a Binary Search Tree, this yields nodes in ascending key order, which is ideal for sorted output.",
        "Postorder (Left → Right → Root): often used for deleting or freeing a tree because children are visited before their parent."
      ],
      "diagram": "process"
    },
    {
      "index": 5,
      "title": "BFS vs. DFS: When to Use Which",
      "points": [
        "Depth-First Search uses a stack (explicit or recursion) and explores a path as deep as possible before backtracking, which is memory-efficient for tall trees.",
        "Breadth-First Search uses a queue to visit nodes level by level, which is perfect for shortest-path in unweighted graphs and for level-order summaries.",
        "In interview settings, start with DFS for recursive problems (traversals, subtree checks) and switch to BFS for level grouping or minimum-depth tasks."
      ],
      "diagram": "compare"
    },
    {
      "index": 6,
      "title": "Binary Search Tree (BST) Invariant",
      "points": [
        "BST Rule: all keys in the left subtree are strictly less than the node’s key, and all keys in the right subtree are strictly greater.",
        "This invariant enables O(log n) average-case search, insert, and delete, but performance depends on balanced height.",
        "Duplicates are typically handled by a policy (reject, count, or place consistently on one side) to preserve ordering."
      ],
      "diagram": "tree"
    },
    {
      "index": 7,
      "title": "BST Operations at a Glance",
      "points": [
        "Search: compare target with current node; go left if smaller, right if larger; stop when found or when a null child is reached.",
        "Insert: follow search path to the null position and attach a new node there; maintain the invariant by choosing left or right correctly.",
        "Delete: handle three cases—leaf (remove), one child (splice up the child), two children (swap with inorder successor/predecessor, then delete)."
      ],
      "diagram": "process"
    },
    {
      "index": 8,
      "title": "Balanced BSTs: AVL vs. Red-Black",
      "points": [
        "AVL Trees maintain strict balance via rotations after insert/delete, providing faster lookups but potentially more updates on writes.",
        "Red-Black Trees enforce a looser color-based invariant; fewer rotations on updates make them common in language libraries and maps.",
        "Both aim to bound height to O(log n), trading stricter balance for lookup speed (AVL) vs. cheaper insert/delete (Red-Black)."
      ],
      "diagram": "compare"
    },
    {
      "index": 9,
      "title": "Heaps vs. BSTs (Don’t Mix Them Up)",
      "points": [
        "A heap is a complete binary tree with the heap property (parent ≤ children for min-heap) but does not impose an inorder key ordering.",
        "Heaps give O(1) access to min/max and O(log n) inserts/deletes, making them ideal for priority queues and scheduling.",
        "BSTs provide full ordered operations (successor, predecessor, range queries) that heaps cannot support efficiently."
      ],
      "diagram": "compare"
    },
    {
      "index": 10,
      "title": "Common Interview Pitfalls",
      "points": [
        "Forgetting null checks at leaf boundaries or during recursion often causes crashes or incorrect base cases.",
        "Mixing preorder/inorder/postorder logic leads to subtle bugs; write tiny examples and trace by hand to verify orders.",
        "Ignoring skew cases during complexity analysis can oversell an O(log n) claim; always mention balance assumptions."
      ],
      "diagram": "process"
    },
    {
      "index": 11,
      "title": "Worked Example: Inorder Traversal Trace",
      "points": [
        "Given a small BST, write the call stack sequence for each recursive step to make control flow explicit.",
        "Annotate when you enter a node, when you traverse left, when you visit root, and when you traverse right.",
        "Conclude with the final inorder list and relate it back to the BST’s sorted-order guarantee."
      ],
      "diagram": "timeline"
    },
    {
      "index": 12,
      "title": "Summary & Next Steps",
      "points": [
        "You learned the tree model, traversal patterns, BST invariants, and trade-offs between balanced trees and heaps.",
        "Practice by coding recursive and iterative traversals, writing BST insert/delete with edge cases, and tracing examples.",
        "Advance to segment trees and tries for range queries and prefix operations, which build on the same hierarchical thinking."
      ],
      "diagram": "compare"
    }
  ]
}
